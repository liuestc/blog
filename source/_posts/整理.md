---
title: 整理
date: 2018-02-10 10:24:25
tags:
---
###  js基础

#### 什么是闭包？举个例子说明

阮大大一句话，闭包是指可以访问其他函数内部变量的函数
红皮书上这样定义：
>闭包是指有权访问其他函数作用域中变量的函数

它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。


#### 解释下什么是原型链？
#### 计时器原理
[具体看这篇](http://link.zhihu.com/?target=http%3A//ejohn.org/blog/how-javascript-timers-work/)    

大概意思是计时器，定时器，点击等异步事件会在其他代码执行完毕之后执行。（和声明顺序无关，即使定时器在前面声明，还是要等到代码块执行完在执行）会在代码执行完毕之后    
#### 常见正则表达式

#### 解释事件委托

DOM绑定过多会引起冗余，可以将事件绑定委托在父元素上，点击父元素时根据target来匹配子元素

好处 占用内存少，不必为后代每个元素绑定事件；如果元素动态删除没必要为新元素新增或者解绑事件
    

#### this是如何工作的
 

 自己答案：
 window下 this指向window
 函数内 this指向该函数
 new关键字 this指向 new出来的新对象

标准答案：
 1. new关键字内，this指向new出来的新对象
 2. 当有`call`,`apply`,`bind`时，this指向传入的对象   。  otherobj.method.call(newObj,params1,params2,...)
 3. 如果函数作为方法被调用，即`obj.method()`，this指向obj
 4. 函数调用无上下文，则浏览器环境下指向window,`use strict`下为`undefined`
 5. 如果适用上述多个规则，则较高的规则将胜出并设置该值。
 6. 如果函数是ES2015箭头函数，它将忽略上面的所有规则，并在创建时接收其周围范围的此值。

#### 原型继承是如何工作的

#### 匿名函数的应用

可以用于IIFE来封装局部范围内的一些代码，以便在其中声明的变量不会泄漏到全局范围

    (function() {
      // Some code here.
    })();

只调用一次，作为回调函数

    setTimeout(function() {
      console.log('Hello world!');
    }, 1000);

函数式编程

    const arr = [1, 2, 3];
    const double = arr.map(function(el) {
      return el * 2;
    });
    console.log(double); // [2, 4, 6]


### Explain Function.prototype.bind.
>The bind() method creates a new function that, when called, has its this keyword set to the provided value, with a given sequence of arguments preceding any provided when the new function is called.

`bind`函数创造一个新函数，当被调用，`this`关键字被设置到所传入的对象中，第二个参数为一个`arguments`数组

    var module = {
      x: 42,
      getX: function() {
        return this.x;
      }
    }
    var retrieveX = module.getX;
    console.log(retrieveX()); // The function gets invoked at the global scope
    // expected output: undefined
    var boundGetX = retrieveX.bind(module);
    console.log(boundGetX());
    // expected output: 42

####  JSONP如何工作？

主要解决跨域问题，脚本可以从别的域加载，访问别的域时返回一个函数

    <script>
        function callBackTest(data){
            console.log(data)
        }
    </script>
    <script src='www.hh.com?callback=callBackTest'></script>
    // www.hh.com?callback=callBackTest 这里返回  callBackTest({name:'ljs'})
 
 缺点：安全性

#### 解释冒泡
`e.stopPropagation()`

#### What's the difference between an "attribute" and a "property"?

Attributes are defined on the HTML markup but properties are defined on the DOM.<input type="text" value="Hello">.



### CSS相关

#### css权重
1. 内联
2. id
3. class 属性 伪类
4. 标签元素 伪元素

权重计算

#### 浮动是如何工作的
浮动是css的一个位置属性，他脱离文档分流，会影响其他元素。并不像`absolute`之类的元素，这类元素直接是从文档流中脱离的。

如果一个父元素只包含浮动元素，则这个父元素高度为0。

浮动的破坏性和包裹性。破坏性指的是破坏文档流，但未完全脱离文档流，会影响其他元素，包裹性是指inline-block化。

清除浮动

    .clearfix:after {
      content: ' ';
      visibility: hidden;
      display: block;
      height: 0;
      clear: both;
    }

#### z-index 如何工作？
z-index仅仅作用于`position`不是`static`的元素
[z-index的层叠关系](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context)

#### 什么是BFC？

块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的部分，是块级盒布局发生的区域，也是浮动元素与其他元素交互的区域。
bfc相当于一个独立王国，不论外面情况如何，独立bfc内岿然不动。

1. float的值不为none
2. position的值不为`static`和`relative`
3. display的值为`table-cell`,`table-caption`,`inline-block`,`flex`,`inline-flex`
4. overflow的值不为`visible`

[bfc](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context)

[流体特性和bfc下的多栏自适应]

bfc的应用

1. 解决padding,margin折叠问题
2. 防止文字环绕


#### 媒体查询
    @media all/print/screen/speech  and (min-device-width:640px){
        
    }

#### css 优化和高效

1. 理解css选择器从右向左匹配，避免使用标签选择器和通用选择器。
2. BEM原则，最好相同部分用一个类，在该类下再扩展不同的类名，是类名相异，这样会使选择器高效。
3. 注意哪些元素可能会引起回流和重绘，避免使用它们。

#### 预处理器的优缺点
1. css  变得可维护
2. 嵌套更容易
3. 可以使用变量，引入文件
4. Mixins生成重复的CSS
5. 可分割，按需引入

###  框架


#### vue生命周期？

#### vuex相关使用
