---
title: 数组降维、去重、排序
date: 2019-07-17 11:36:40
tags:
---

数组降维，去重，排序

```
//输入
 var arr1 = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];
// 输出
[1, 2, 2, 3, 4, 5, 5, 6, 7, 8, 9, 11, 12, 12, 13, 14, 10]
```

思考：

首先是降维，这也是最重要的，降维可以采用flat、reduce、递归完成

### flat 方法：

`flat`的参数是降低的维度，最好理解的就是数最里层括号数-1，默认是1，就是不降维，传入`Infinity`直接降为1维

```
Array.from(new Set(arr.flat(Infinity))).sort((a,b)=>{ return a-b});
```

### reduce方法

先复习下reduce方法：
[reduce](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)

>reduce(reducer,initialValue) 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。

reducer 函数接收4个参数:

Accumulator (acc) (累计器)
Current Value (cur) (当前值)
Current Index (idx) (当前索引)
Source Array (src) (源数组)

如果没有提供initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供initialValue，从索引0开始。

其实理解就是多对一，不断迭代，把上一步结果不断和下一个值迭代，最终输出一个值

```
flat=(arr)=>arr.reduce((acc,cur)=> acc.concat(Array.isArray(cur)?flat(cur):cur),[])
```

### 递归

其实上面的reduce已经涉及递归了

自己写了写实现并不优雅

```
function flatArr(array){
    let newArr=[]
    function flat(arr){
        let type=Array.isArray(arr)
        if(type){
            for(let i=0;i<arr.length;i++){
                Array.isArray(arr[i]) ? flat(arr[i]) : newArr.push(arr[i])
            }
        }
        else{
            newArr.push(arr)
        }
    }
    flat(array)
    
    return [...new Set(newArr)].sort((a,b)=>a-b)
}
```

看看官方的flat怎么写

[flat](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat)


```
function flatten(input) {
  const stack = [...input];
  const res = [];
  while (stack.length) {
    // 使用 pop 从 stack 中取出并移除值
    const next = stack.pop();
    if (Array.isArray(next)) {
      // 使用 push 送回内层数组中的元素，不会改动原始输入 original input
      stack.push(...next);
    } else {
      res.push(next);
    }
  }
  // 使用 reverse 恢复原数组的顺序
  return res.reverse();
}
```

弹栈然后判断该元素是否是数据，如果不是去括号，推进栈中，如果是推进新数组，等到栈空时，新数组就是降维数组